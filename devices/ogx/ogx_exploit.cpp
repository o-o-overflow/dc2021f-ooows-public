#include <boost/asio.hpp>
#include <fstream>
#include <iostream>
#include <thread>

#include "Driver.h"
#include "spdlog/sinks/stdout_sinks.h"
#include "spdlog/spdlog.h"

using namespace std::chrono_literals;

static const char* TEST_DEVICE_PATH = "/tmp/ogx_test.socket";

static const std::vector<uint8_t> OGX_PUB_KEY{
    0x87, 0x50, 0x3e, 0x79, 0x38, 0xf7, 0xac, 0xa0, 0x31, 0xcb, 0x9c, 0xd0, 0x3e, 0x71, 0x76, 0xe9,
    0x6a, 0xe7, 0x2c, 0x4b, 0x40, 0xa5, 0x98, 0xf5, 0x51, 0x12, 0xa8, 0xf7, 0x06, 0x4f, 0x23, 0x73,
};
static const std::vector<uint8_t> OGX_SEC_KEY{
    0x26, 0x5c, 0xc2, 0x59, 0xa1, 0x88, 0x07, 0x55, 0x0f, 0x3a, 0x3c, 0xd2, 0x56, 0x4f, 0x00, 0x79,
    0xa8, 0x54, 0x34, 0xb4, 0xbf, 0x44, 0x11, 0x0a, 0x64, 0x07, 0x84, 0x56, 0x71, 0x63, 0xdb, 0x62,
};
static const std::vector<uint8_t> USER_PUB_KEY{
    0x45, 0xb7, 0xbd, 0xf7, 0xa2, 0xf2, 0xc1, 0x6f, 0x38, 0xb1, 0xdd, 0xab, 0x2f, 0x58, 0x5f, 0x44,
    0x9d, 0xc3, 0x9b, 0x6c, 0xfb, 0x68, 0x37, 0xb7, 0x87, 0xad, 0x6c, 0x3e, 0x60, 0x6e, 0x2c, 0x14,
};
static const std::vector<uint8_t> USER_SEC_KEY{
    0xd4, 0x89, 0xa5, 0xe8, 0x8f, 0x68, 0xea, 0x92, 0x43, 0xda, 0xdd, 0x29, 0x81, 0x07, 0xe3, 0x74,
    0x33, 0xa2, 0x60, 0x80, 0x42, 0xeb, 0xbe, 0x7f, 0xe9, 0x27, 0x3d, 0xf3, 0x2f, 0xbf, 0x7c, 0xbb,
};

static std::vector<uint8_t> ReadFile(const std::string& path) {
    std::ifstream input(path, std::ios::binary);
    std::vector<uint8_t> data(std::istreambuf_iterator<char>(input), {});
    return data;
}

static void WriteFile(const std::string& path, const std::vector<uint8_t>& data) {
    std::ofstream output(path, std::ios::binary);
    output.write(reinterpret_cast<const char*>(data.data()), data.size());
}

int main() {
    spdlog::set_pattern("%L%C%m%dT%T%z %n: %v");
    auto log = spdlog::stdout_color_mt("ogx");
    assert(log && "null logger");
    log->set_level(spdlog::level::debug);

    WriteFile("ogx.pub", OGX_PUB_KEY);
    WriteFile("ogx.sec", OGX_SEC_KEY);

    boost::asio::io_context context;
    TestDriver driver(OGX_PUB_KEY, USER_PUB_KEY, USER_SEC_KEY, context, TEST_DEVICE_PATH);

    auto signal_code = ReadFile("ogx_enclave_signal.bin");
    LoadEvent signal_load(1, signal_code, {});
    log->info("loading signal enclave");
    driver.WriteEvent(&signal_load);

    // Read exits of signal and flag enclaves
    log->info("reading signal enclave response");
    auto result = driver.ReadEvent();
    assert(result.has_value());
    log->info("reading flag enclave response");
    result = driver.ReadEvent();
    // assert(result.has_value());

    // Schedule an enclave on the old flag enclave to read out the flag
    log->info("loading read enclave");
    auto read_code = ReadFile("ogx_enclave_read.bin");
    LoadEvent read_load(0, read_code, {});
    driver.WriteEvent(&read_load);

    log->info("reading read enclave response");
    result = driver.ReadEvent();
    assert(result.has_value());
    auto& [sender, event] = *result;
    assert(event);
    auto response = std::dynamic_pointer_cast<ResponseEvent>(event);
    assert(response);
    std::cerr << "FLAG: " << reinterpret_cast<const char*>(response->response_.data()) << "\n";

    return 0;
}
